package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates XPC RPC service definitions
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	filename := file.GeneratedFilenamePrefix + ".granted_rpc.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-granted-rpc-go. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`import (
		"context"
		"encoding/json"
		"fmt"
		"google.golang.org/protobuf/encoding/protojson"
		"github.com/chrnorm/granted-rpc-go"
	)`)
	g.P()

	// Generate constants for RPCs
	g.P("// These constants are the fully-qualified names of the RPCs defined in this package.")
	g.P("const (")
	for _, service := range file.Services {
		serviceName := string(service.Desc.Name())
		for _, method := range service.Methods {
			methodName := string(method.Desc.Name())
			constName := serviceName + methodName + "Procedure"
			g.P("// ", constName, " is the fully-qualified name of the ", serviceName, "'s ", methodName, " RPC.")
			g.P(constName, " = \"/", file.Desc.Package(), ".", serviceName, "/", methodName, "\"")
		}
	}
	g.P(")")
	g.P()

	// Generate code for each service
	for _, service := range file.Services {
		genService(g, service)
	}
}

func genService(g *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := string(service.Desc.Name())

	// Generate handler interface
	if service.Comments.Leading.String() != "" {
		g.P(strings.TrimSuffix(service.Comments.Leading.String(), "\n"))
	}
	g.P("type ", serviceName, "Handler interface {")
	for _, method := range service.Methods {
		if method.Comments.Leading.String() != "" {
			g.P("	", strings.TrimSuffix(method.Comments.Leading.String(), "\n"))
		}
		g.P("	", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate client struct and constructor
	if service.Comments.Leading.String() != "" {
		g.P(strings.TrimSuffix(service.Comments.Leading.String(), "\n"))
	}
	g.P("type ", serviceName, "Client struct {")
	g.P("	t grantedrpc.Transport")
	g.P("}")
	g.P()

	g.P("func New", serviceName, "Client(t grantedrpc.Transport) *", serviceName, "Client {")
	g.P("	return &", serviceName, "Client{t: t}")
	g.P("}")
	g.P()

	// Generate Register function
	g.P("func Register", serviceName, "(r *grantedrpc.Router, svc ", serviceName, "Handler) {")
	for _, method := range service.Methods {
		methodName := string(method.Desc.Name())
		constName := serviceName + methodName + "Procedure"
		g.P("	r.Register(", constName, ", new(", method.Input.GoIdent, "), new(", method.Output.GoIdent, "), svc.", method.GoName, ")")
	}
	g.P("}")
	g.P()

	// Generate methods for each RPC
	for _, method := range service.Methods {
		genMethod(g, method, service)
	}
}

func genMethod(g *protogen.GeneratedFile, method *protogen.Method, service *protogen.Service) {
	serviceName := string(service.Desc.Name())
	methodName := string(method.Desc.Name())
	constName := serviceName + methodName + "Procedure"

	if method.Comments.Leading.String() != "" {
		g.P(strings.TrimSuffix(method.Comments.Leading.String(), "\n"))
	}
	g.P("func (c *", serviceName, "Client) ", methodName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	g.P("	reqJson, err := protojson.Marshal(req)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to marshal request: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	msg := struct{")
	g.P("		Procedure string `json:\"procedure\"`")
	g.P("		Request json.RawMessage `json:\"request\"`")
	g.P("	}{")
	g.P("		Procedure: ", constName, ",")
	g.P("		Request: reqJson,")
	g.P("	}")
	g.P()

	g.P("	inputJson, err := json.Marshal(msg)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to marshal wrapper: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	respJson, err := c.t.SendMessage(ctx, string(inputJson))")
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P()

	g.P("	var respWrapper struct{")
	g.P("		Procedure string `json:\"procedure\"`")
	g.P("		Response json.RawMessage `json:\"response\"`")
	g.P("	}")
	g.P()

	g.P("	if err := json.Unmarshal([]byte(respJson), &respWrapper); err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to unmarshal response wrapper: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	if respWrapper.Procedure != ", constName, " {")
	g.P("		return nil, fmt.Errorf(\"mismatched procedure in response: got %s want %s\", respWrapper.Procedure, ", constName, ")")
	g.P("	}")
	g.P()

	g.P("	resp := new(", method.Output.GoIdent, ")")
	g.P("	if err := protojson.Unmarshal(respWrapper.Response, resp); err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to unmarshal response: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	return resp, nil")
	g.P("}")
	g.P()
}
